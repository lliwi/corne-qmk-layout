#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */
 enum layer_names {
    _QWERTY = 0,
    _NUMS,
    _SYMBOLS,
    _MEDIA
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_QWERTY] = LAYOUT_split_3x6_3(KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_BSPC, RSFT_T(KC_CAPS), KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_LCTL, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_ESC, KC_LGUI, MO(1), KC_ENT, KC_SPC, MO(2), KC_RALT),
    [_NUMS] = LAYOUT_split_3x6_3(KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_NO, KC_BSPC, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_LSFT, KC_NO, KC_NO, KC_LCTL, KC_LALT, KC_DEL, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_LGUI, KC_TRNS, KC_ENT, KC_SPC, MO(3), KC_RALT),
    [_SYMBOLS] = LAYOUT_split_3x6_3(KC_TAB, KC_NO, KC_UP, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_MINS, KC_EQL, KC_BSPC, RSFT(KC_LSFT), KC_LEFT, KC_DOWN, KC_RGHT, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LBRC, KC_RBRC, KC_NUHS, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_INT1, KC_TRNS, KC_LGUI, MO(3), KC_ENT, KC_SPC, KC_TRNS, KC_RALT),
    [_MEDIA] = LAYOUT_split_3x6_3(RM_ON, RM_OFF, KC_NO, KC_NO, KC_NO, KC_NO, KC_BRID, KC_BRIU, KC_NO, KC_NO, KC_NO, KC_NO, RM_TOGG, RM_HUEU, RM_SATU, RM_VALU, KC_NO, KC_NO, KC_MUTE, KC_VOLD, KC_VOLU, KC_NO, KC_NO, KC_NO, RM_NEXT, RM_HUED, RM_SATD, RM_VALD, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LGUI, KC_TRNS, KC_ENT, KC_SPC, KC_TRNS, KC_RALT)
};

// Inicialización del teclado
void keyboard_post_init_user(void) {
    #ifdef RGBLIGHT_ENABLE
    // Debug: Esperar un poco para que el USB se estabilice
    wait_ms(500);

    // Forzar encendido del RGBLIGHT
    rgblight_enable_noeeprom();  // No guardar en EEPROM
    rgblight_mode_noeeprom(RGBLIGHT_MODE_STATIC_LIGHT);

    // Rojo brillante al máximo para test
    rgblight_sethsv_noeeprom(0, 255, 150);
    #endif
}

// Función de test continuo para debug
void housekeeping_task_user(void) {
    #ifdef RGBLIGHT_ENABLE
    static uint32_t timer = 0;
    static bool led_state = false;

    // Parpadear cada 500ms para confirmar que el código se ejecuta
    if (timer_elapsed32(timer) > 500) {
        timer = timer_read32();
        led_state = !led_state;

        if (led_state) {
            // Encender todos en rojo brillante
            rgblight_sethsv_noeeprom(0, 255, 150);  // Rojo
        } else {
            // Verde brillante (para ver el cambio)
            rgblight_sethsv_noeeprom(85, 255, 150);  // Verde (hue=85)
        }
    }
    #endif
}

// Configuración del OLED para mostrar las capas
#ifdef OLED_ENABLE

// Incluir la animación demon
#include "demon.c"

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (!is_keyboard_master()) {
        return OLED_ROTATION_270;  // Rotar 90 grados a la izquierda (vertical)
    }
    return rotation;
}

void oled_render_layer_state(void) {
    oled_write_P(PSTR("Layer: "), false);
    switch (get_highest_layer(layer_state)) {
        case _QWERTY:
            oled_write_ln_P(PSTR("QWERTY"), false);
            break;
        case _NUMS:
            oled_write_ln_P(PSTR("NUMS"), false);
            break;
        case _SYMBOLS:
            oled_write_ln_P(PSTR("SYMBOLS"), false);
            break;
        case _MEDIA:
            oled_write_ln_P(PSTR("MEDIA"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Unknown"), false);
    }
}

void oled_render_lock_status(void) {
    led_t led_state = host_keyboard_led_state();

    oled_write_P(PSTR("Lock: "), false);
    if (led_state.caps_lock) {
        oled_write_P(PSTR("[CAPS]"), true);  // Invertido para resaltar
    } else {
        oled_write_P(PSTR("      "), false);
    }
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_mods(void) {
    uint8_t mods = get_mods() | get_oneshot_mods();

    oled_write_P(PSTR("Mods: "), false);
    oled_write_P((mods & MOD_MASK_SHIFT) ? PSTR("S") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_CTRL)  ? PSTR("C") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_ALT)   ? PSTR("A") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_GUI)   ? PSTR("G") : PSTR("-"), false);
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_wpm_status(void) {
    char wpm_str[5];
    sprintf(wpm_str, "%03d", get_current_wpm());
    oled_write_P(PSTR("WPM:  "), false);
    oled_write(wpm_str, false);
    oled_write_ln_P(PSTR(""), false);
}

bool oled_task_user(void) {
    if (is_keyboard_master()) {
        // Lado maestro: mostrar información de capas y estado
        oled_render_layer_state();
        oled_render_lock_status();
        oled_render_mods();
        oled_render_wpm_status();
    } else {
        // Lado secundario: mostrar animación demon
        oled_render_anim();

        // Mostrar WPM manualmente en el lado secundario
        char wpm_str[5];
        sprintf(wpm_str, "%03d", get_current_wpm());
        oled_set_cursor(0, 1);
        oled_write_P(PSTR("WPM"), false);
        oled_set_cursor(0, 2);
        oled_write(wpm_str, false);
    }
    return false;
}
#endif

#ifdef OTHER_KEYMAP_C
#    include OTHER_KEYMAP_C
#endif // OTHER_KEYMAP_C

