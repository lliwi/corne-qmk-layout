#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */
 enum layer_names {
    _QWERTY = 0,
    _NUMS,
    _SYMBOLS,
    _MEDIA
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_QWERTY] = LAYOUT_split_3x6_3(KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_BSPC, RSFT_T(KC_CAPS), KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_LCTL, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_ESC, KC_LGUI, MO(1), KC_SPC, KC_ENT, MO(2), KC_RALT),
    [_NUMS] = LAYOUT_split_3x6_3(KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_MINS, KC_BSPC, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_LSFT, KC_NO, KC_NO, KC_LCTL, KC_LALT, KC_DEL, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_LGUI, KC_TRNS, KC_SPC, KC_ENT, MO(3), KC_RALT),
    [_SYMBOLS] = LAYOUT_split_3x6_3(KC_TAB, KC_AT, KC_UP, KC_DLR, KC_PERC, KC_CIRC, KC_AMPR, KC_ASTR, KC_LPRN, KC_RPRN, KC_MINS, KC_EQL, RSFT(KC_LSFT), KC_LEFT, KC_DOWN, KC_RGHT, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LBRC, KC_RBRC, KC_NUHS, KC_LCTL, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_INT3, KC_NUBS, KC_NO, KC_GRV, KC_LGUI, MO(3), KC_SPC, KC_ENT, KC_TRNS, KC_RALT),
    [_MEDIA] = LAYOUT_split_3x6_3(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_BRID, KC_BRIU, KC_NO, KC_NO, KC_NO, KC_NO, RM_TOGG, RM_HUEU, RM_SATU, RM_VALU, KC_NO, KC_NO, KC_MUTE, KC_VOLD, KC_VOLU, KC_F20, KC_NO, KC_NO, RM_NEXT, RM_HUED, RM_SATD, RM_VALD, KC_NO, KC_NO, KC_MPLY, KC_MSTP, KC_NO, KC_NO, KC_NO, KC_NO, KC_LGUI, KC_TRNS, KC_SPC, KC_ENT, KC_TRNS, KC_RALT)
};

// Configuración del OLED para mostrar las capas
#ifdef OLED_ENABLE

// Selecciona la animación que quieres usar (descomenta solo UNA)
// #define USE_DEMON_ANIM
// #define USE_CRAB_ANIM
// #define USE_MUSIC_BARS_ANIM
#define USE_BONGO_ANIM

// Configurar defines antes de incluir animation-utils.c
#ifdef USE_DEMON_ANIM
    #define ANIM_SCROLL true
    #define ANIM_FRAME_WIDTH 32
    #define ANIM_SIZE 144
#elif defined(USE_CRAB_ANIM)
    #define ANIM_SCROLL true
    #define ANIM_FRAME_WIDTH 72
    #define ANIM_SIZE 288
    #define ANIM_BOUNCE true
#endif

// Incluir utilidades de animación (necesario para demon y crab)
#if defined(USE_DEMON_ANIM) || defined(USE_CRAB_ANIM)
    #include "animations/animation-utils.c"
#endif

// Incluir la animación seleccionada
#ifdef USE_DEMON_ANIM
    #include "animations/demon.c"
    #define oled_render_anim demon_oled_render_anim
#elif defined(USE_CRAB_ANIM)
    #include "animations/crab.c"
    #define oled_render_anim crab_oled_render_anim
#elif defined(USE_MUSIC_BARS_ANIM)
    #include "animations/music-bars.c"
    #define oled_render_anim music_bars_oled_render_anim
#elif defined(USE_BONGO_ANIM)
    #include "animations/bongo.c"
    #define oled_render_anim bongo_oled_render_anim
#endif

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (!is_keyboard_master()) {
        return OLED_ROTATION_180;  // Rotación 180 grados para todas las animaciones
    }
    return rotation;
}

void oled_render_layer_state(void) {
    oled_write_P(PSTR("Layer: "), false);
    switch (get_highest_layer(layer_state)) {
        case _QWERTY:
            oled_write_ln_P(PSTR("QWERTY"), false);
            break;
        case _NUMS:
            oled_write_ln_P(PSTR("NUMS"), false);
            break;
        case _SYMBOLS:
            oled_write_ln_P(PSTR("SYMBOLS"), false);
            break;
        case _MEDIA:
            oled_write_ln_P(PSTR("MEDIA"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Unknown"), false);
    }
}

void oled_render_lock_status(void) {
    led_t led_state = host_keyboard_led_state();

    oled_write_P(PSTR("Lock: "), false);
    if (led_state.caps_lock) {
        oled_write_P(PSTR("[CAPS]"), true);  // Invertido para resaltar
    } else {
        oled_write_P(PSTR("      "), false);
    }
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_mods(void) {
    uint8_t mods = get_mods() | get_oneshot_mods();

    oled_write_P(PSTR("Mods: "), false);
    oled_write_P((mods & MOD_MASK_SHIFT) ? PSTR("S") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_CTRL)  ? PSTR("C") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_ALT)   ? PSTR("A") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_GUI)   ? PSTR("G") : PSTR("-"), false);
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_wpm_status(void) {
    char wpm_str[5];
    sprintf(wpm_str, "%03d", get_current_wpm());
    oled_write_P(PSTR("WPM:  "), false);
    oled_write(wpm_str, false);
    oled_write_ln_P(PSTR(""), false);
}

bool oled_task_user(void) {
    if (is_keyboard_master()) {
        // Lado maestro: mostrar información de capas y estado
        oled_render_layer_state();
        oled_render_lock_status();
        oled_render_mods();
    } else {
        // Lado secundario: mostrar solo la animación
        oled_render_anim();
    }
    return false;
}
#endif

// Indicadores RGB para Caps Lock y capas
#ifdef RGB_MATRIX_ENABLE
bool rgb_matrix_indicators_user(void) {
    uint8_t current_layer = get_highest_layer(layer_state);
    /*
    // Prioridad 1: Detectar si estamos en la capa MEDIA 
    if (current_layer == _MEDIA) {
        // Todos los LEDs en rojo
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            rgb_matrix_set_color(i, 255, 0, 0);  // ROJO
        }
        return false;
    }
    */

    // Prioridad 2: Detectar si estamos en la capa SYMBOLS
    if (current_layer == _SYMBOLS) {
        // Índices correctos identificados mediante diagnóstico:
        // W: 18, A: 22, S: 19, D: 16
        uint8_t wasd_leds[] = {18, 22, 19, 16};  // W, A, S, D

        // Iterar sobre TODOS los LEDs (ambos lados del teclado)
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            // Verificar si el LED actual es uno de W, A, S, D
            bool is_wasd = false;
            for (uint8_t j = 0; j < sizeof(wasd_leds); j++) {
                if (i == wasd_leds[j]) {
                    is_wasd = true;
                    break;
                }
            }

            if (is_wasd) {
                // W, A, S, D en blanco
                rgb_matrix_set_color(i, 255, 255, 255);
            } else {
                // Resto de LEDs en amarillo (255, 255, 0 en RGB)
                rgb_matrix_set_color(i, 255, 221, 51); // AMARILLO
            }
        }
        return false;
    }

    // Prioridad 3: Detectar si estamos en la capa NUMS
    if (current_layer == _NUMS) {
        // Todos los LEDs en naranja
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            rgb_matrix_set_color(i, 255, 64, 25);  // NARANJA
        }
        return false;
    }

    // Prioridad 4: Detectar si Caps Lock está activo (en capa base)
    if (host_keyboard_led_state().caps_lock) {
        // Poner todos los LEDs en blanco cuando Caps Lock está activo
        // Usar brillo más bajo para evitar problemas
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            rgb_matrix_set_color(i, 200, 200, 200);  // Blanco suave
        }
    }
    // Si ninguna condición está activa, el RGB Matrix usa el modo configurado (rainbow)
    return false;
}
#endif

#ifdef OTHER_KEYMAP_C
#    include OTHER_KEYMAP_C
#endif // OTHER_KEYMAP_C



