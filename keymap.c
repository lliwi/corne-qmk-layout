#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */
enum layer_names {
    _QWERTY = 0,
    _NUMS,
    _SYMBOLS,
    _MEDIA
};

// Custom keycodes para macros dinámicas
enum custom_keycodes {
    MACRO1 = SAFE_RANGE,
    MACRO2,
    MACRO3,
    MACRO_STOP
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_QWERTY] = LAYOUT_split_3x6_3(KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_BSPC, RSFT_T(KC_CAPS), KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_LCTL, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_ESC, KC_LGUI, MO(1), KC_SPC, KC_ENT, MO(2), KC_RALT),
    [_NUMS] = LAYOUT_split_3x6_3(KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_MINS, KC_BSPC, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_LSFT, KC_NO, KC_NO, KC_LCTL, KC_LALT, KC_DEL, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_LGUI, KC_TRNS, KC_SPC, KC_ENT, MO(3), KC_RALT),
    [_SYMBOLS] = LAYOUT_split_3x6_3(KC_TAB, KC_AT, KC_UP, KC_DLR, KC_PERC, KC_CIRC, KC_AMPR, KC_ASTR, KC_LPRN, KC_RPRN, KC_MINS, KC_EQL, RSFT(KC_LSFT), KC_LEFT, KC_DOWN, KC_RGHT, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LBRC, KC_RBRC, KC_NUHS, KC_LCTL, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_INT3, KC_NUBS, KC_NO, KC_GRV, KC_LGUI, MO(3), KC_SPC, KC_ENT, KC_TRNS, KC_RALT),
    [_MEDIA] = LAYOUT_split_3x6_3(LGUI(KC_1), LGUI(KC_2), LGUI(KC_3), LGUI(KC_4), LGUI(KC_5), LGUI(KC_6), KC_BRID, KC_BRIU, KC_NO, KC_NO, KC_NO, KC_NO, RM_TOGG, RM_HUEU, RM_SATU, RM_VALU, KC_NO, KC_NO, KC_MUTE, KC_VOLD, KC_VOLU, KC_F20, KC_NO, KC_NO, RM_NEXT, RM_HUED, RM_SATD, RM_VALD, KC_NO, KC_NO, KC_MPLY, KC_MSTP, MACRO1, MACRO2, MACRO3, MACRO_STOP, KC_LGUI, KC_TRNS, KC_SPC, KC_ENT, KC_TRNS, KC_RALT)
};

// ============================================================================
// DYNAMIC MACRO IMPLEMENTATION
// ============================================================================

#define MACRO_BUFFER_SIZE 128
#define HOLD_THRESHOLD 200  // ms para detectar hold vs tap
#define DOUBLE_TAP_TERM 300 // ms para detectar doble tap
#define MACRO_EEPROM_MAGIC 0x4D43  // "MC" (Macro Config) magic number para validar datos

// Estructura para almacenar una macro
typedef struct {
    uint16_t buffer[MACRO_BUFFER_SIZE];
    uint16_t length;
    bool is_recording;
    uint16_t press_timer;
    uint16_t last_tap_time;  // Para detectar doble tap
    bool pending_playback;   // Indica si hay reproducción pendiente
    deferred_token playback_token; // Token para cancelar reproducción pendiente
} dynamic_macro_t;

// Estado de las 3 macros
static dynamic_macro_t macros[3] = {0};
static int8_t currently_recording = -1; // -1 = no recording, 0-2 = macro index

// Forward declarations
void playback_macro(uint8_t macro_idx);
void save_macros_to_eeprom(void);
void load_macros_from_eeprom(void);

// Callback para reproducir macro después del delay
uint32_t deferred_playback_callback(uint32_t trigger_time, void *cb_arg) {
    uint8_t macro_idx = (uintptr_t)cb_arg;
    if (macro_idx < 3 && macros[macro_idx].pending_playback) {
        macros[macro_idx].pending_playback = false;
        playback_macro(macro_idx);
    }
    return 0; // No repetir
}

// Función auxiliar para grabar un keycode en la macro actual
void record_key_to_macro(uint8_t macro_idx, uint16_t keycode, bool pressed) {
    if (macro_idx >= 3) return;
    dynamic_macro_t *macro = &macros[macro_idx];

    if (macro->length >= MACRO_BUFFER_SIZE - 1) {
        // Buffer lleno, parar grabación
        macro->is_recording = false;
        currently_recording = -1;
        return;
    }

    // Guardar keycode con flag de pressed/released
    macro->buffer[macro->length++] = pressed ? keycode : (keycode | 0x8000);
}

// Función auxiliar para convertir mod-tap a modificador base
uint16_t convert_modtap_to_mod(uint16_t keycode) {
    // Detectar si es un mod-tap
    if (keycode >= QK_MOD_TAP && keycode <= QK_MOD_TAP_MAX) {
        // Extraer el modificador del mod-tap
        uint8_t mod = QK_MOD_TAP_GET_MODS(keycode);

        // Convertir a keycode de modificador
        if (mod & MOD_LCTL) return KC_LCTL;
        if (mod & MOD_LSFT) return KC_LSFT;
        if (mod & MOD_LALT) return KC_LALT;
        if (mod & MOD_LGUI) return KC_LGUI;
        if (mod & MOD_RCTL) return KC_RCTL;
        if (mod & MOD_RSFT) return KC_RSFT;
        if (mod & MOD_RALT) return KC_RALT;
        if (mod & MOD_RGUI) return KC_RGUI;
    }
    return keycode;
}

// Función para reproducir una macro
void playback_macro(uint8_t macro_idx) {
    if (macro_idx >= 3) return;
    dynamic_macro_t *macro = &macros[macro_idx];

    if (macro->length == 0) return; // Macro vacía

    for (uint16_t i = 0; i < macro->length; i++) {
        uint16_t keycode = macro->buffer[i];
        bool pressed = !(keycode & 0x8000);
        keycode &= 0x7FFF; // Limpiar el bit de released

        // Convertir mod-tap a modificador base si es necesario
        keycode = convert_modtap_to_mod(keycode);

        if (pressed) {
            register_code16(keycode);
        } else {
            unregister_code16(keycode);
        }
        wait_ms(10); // Pequeña pausa entre teclas
    }

    // IMPORTANTE: Limpiar cualquier tecla que pueda haber quedado registrada
    clear_keyboard();
}

// Función para iniciar grabación de una macro
void start_recording_macro(uint8_t macro_idx) {
    if (macro_idx >= 3) return;

    // Parar cualquier grabación previa
    if (currently_recording >= 0) {
        macros[currently_recording].is_recording = false;
    }

    // Iniciar nueva grabación
    macros[macro_idx].length = 0;
    macros[macro_idx].is_recording = true;
    currently_recording = macro_idx;
}

// Función para parar grabación
void stop_recording_macro(void) {
    if (currently_recording >= 0) {
        macros[currently_recording].is_recording = false;
        currently_recording = -1;
        // Guardar en EEPROM después de grabar
        save_macros_to_eeprom();
    }
}

// Función para borrar una macro
void clear_macro(uint8_t macro_idx) {
    if (macro_idx >= 3) return;

    // Cancelar cualquier reproducción pendiente
    if (macros[macro_idx].pending_playback) {
        cancel_deferred_exec(macros[macro_idx].playback_token);
        macros[macro_idx].pending_playback = false;
    }

    macros[macro_idx].length = 0;
    macros[macro_idx].is_recording = false;
    macros[macro_idx].last_tap_time = 0;

    // Guardar en EEPROM después de borrar
    save_macros_to_eeprom();
}

// ============================================================================
// PERSISTENCIA EN EEPROM
// ============================================================================

// Estructura para guardar macros en EEPROM
typedef struct {
    uint16_t magic;  // Magic number para validar datos
    uint16_t lengths[3];  // Longitud de cada macro
    uint16_t buffers[3][MACRO_BUFFER_SIZE];  // Buffer de cada macro
} macro_eeprom_config_t;

// Guardar macros en EEPROM
void save_macros_to_eeprom(void) {
    macro_eeprom_config_t config;

    config.magic = MACRO_EEPROM_MAGIC;
    for (uint8_t i = 0; i < 3; i++) {
        config.lengths[i] = macros[i].length;
        for (uint16_t j = 0; j < MACRO_BUFFER_SIZE; j++) {
            config.buffers[i][j] = macros[i].buffer[j];
        }
    }

    eeconfig_update_user_datablock(&config, 0, sizeof(config));
}

// Cargar macros desde EEPROM
void load_macros_from_eeprom(void) {
    macro_eeprom_config_t config;
    eeconfig_read_user_datablock(&config, 0, sizeof(config));

    // Verificar magic number
    if (config.magic != MACRO_EEPROM_MAGIC) {
        // Datos inválidos, no cargar nada
        return;
    }

    // Cargar macros
    for (uint8_t i = 0; i < 3; i++) {
        if (config.lengths[i] <= MACRO_BUFFER_SIZE) {
            macros[i].length = config.lengths[i];
            for (uint16_t j = 0; j < config.lengths[i]; j++) {
                macros[i].buffer[j] = config.buffers[i][j];
            }
        }
    }
}

// Process record para manejar las teclas de macro
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    // Si estamos grabando, capturar todas las teclas (excepto las de control de macro y capas)
    if (currently_recording >= 0) {
        switch (keycode) {
            case MACRO1:
            case MACRO2:
            case MACRO3:
            case MACRO_STOP:
                // No grabar las teclas de control de macro
                break;
            case QK_MOMENTARY ... QK_MOMENTARY_MAX:  // MO(layer)
            case QK_LAYER_TAP ... QK_LAYER_TAP_MAX:   // LT(layer, kc)
            case QK_TOGGLE_LAYER ... QK_TOGGLE_LAYER_MAX:  // TG(layer)
            case QK_ONE_SHOT_LAYER ... QK_ONE_SHOT_LAYER_MAX:  // OSL(layer)
                // No grabar teclas de capa para evitar problemas
                break;
            default:
                // Grabar cualquier otra tecla (incluyendo mod-tap)
                // Los mod-tap se convertirán a modificadores durante playback
                record_key_to_macro(currently_recording, keycode, record->event.pressed);
                return true; // Permitir que la tecla se procese normalmente
        }
    }

    // Manejar las teclas de macro
    switch (keycode) {
        case MACRO1:
        case MACRO2:
        case MACRO3: {
            uint8_t macro_idx = keycode - MACRO1;

            if (record->event.pressed) {
                // Tecla presionada: iniciar timer
                macros[macro_idx].press_timer = timer_read();
            } else {
                // Tecla liberada: determinar si fue hold o tap
                uint16_t elapsed = timer_elapsed(macros[macro_idx].press_timer);

                if (elapsed >= HOLD_THRESHOLD) {
                    // Hold: iniciar/parar grabación de esta macro
                    if (currently_recording == macro_idx) {
                        // Ya estábamos grabando esta macro: parar
                        stop_recording_macro();
                    } else {
                        // No estábamos grabando o estábamos grabando otra: iniciar grabación
                        start_recording_macro(macro_idx);
                    }
                } else {
                    // Tap corto: verificar si es doble tap
                    uint16_t now = timer_read();
                    uint16_t time_since_last_tap = now - macros[macro_idx].last_tap_time;

                    if (macros[macro_idx].pending_playback && time_since_last_tap < DOUBLE_TAP_TERM) {
                        // Doble tap detectado: cancelar reproducción pendiente y borrar macro
                        cancel_deferred_exec(macros[macro_idx].playback_token);
                        macros[macro_idx].pending_playback = false;
                        clear_macro(macro_idx);
                    } else {
                        // Tap simple: programar reproducción retrasada (solo si no estamos grabando)
                        if (currently_recording < 0 && macros[macro_idx].length > 0) {
                            // Cancelar cualquier reproducción pendiente previa
                            if (macros[macro_idx].pending_playback) {
                                cancel_deferred_exec(macros[macro_idx].playback_token);
                            }

                            // Programar reproducción después de DOUBLE_TAP_TERM
                            macros[macro_idx].pending_playback = true;
                            macros[macro_idx].playback_token = defer_exec(DOUBLE_TAP_TERM, deferred_playback_callback, (void*)(uintptr_t)macro_idx);
                        }
                        // Actualizar timestamp del último tap
                        macros[macro_idx].last_tap_time = now;
                    }
                }
            }
            return false;
        }

        case MACRO_STOP:
            if (record->event.pressed) {
                // MACRO_STOP simplemente para cualquier grabación en curso
                stop_recording_macro();
            }
            return false;
    }

    return true;
}

// ============================================================================
// INICIALIZACIÓN
// ============================================================================

// Cargar macros desde EEPROM al iniciar
void keyboard_post_init_user(void) {
    load_macros_from_eeprom();
}

// Configuración del OLED para mostrar las capas
#ifdef OLED_ENABLE

// Selecciona la animación que quieres usar (descomenta solo UNA)
// #define USE_DEMON_ANIM
// #define USE_CRAB_ANIM
// #define USE_MUSIC_BARS_ANIM
#define USE_BONGO_ANIM

// Configurar defines antes de incluir animation-utils.c
#ifdef USE_DEMON_ANIM
    #define ANIM_SCROLL true
    #define ANIM_FRAME_WIDTH 32
    #define ANIM_SIZE 144
#elif defined(USE_CRAB_ANIM)
    #define ANIM_SCROLL true
    #define ANIM_FRAME_WIDTH 72
    #define ANIM_SIZE 288
    #define ANIM_BOUNCE true
#endif

// Incluir utilidades de animación (necesario para demon y crab)
#if defined(USE_DEMON_ANIM) || defined(USE_CRAB_ANIM)
    #include "animations/animation-utils.c"
#endif

// Incluir la animación seleccionada
#ifdef USE_DEMON_ANIM
    #include "animations/demon.c"
    #define oled_render_anim demon_oled_render_anim
#elif defined(USE_CRAB_ANIM)
    #include "animations/crab.c"
    #define oled_render_anim crab_oled_render_anim
#elif defined(USE_MUSIC_BARS_ANIM)
    #include "animations/music-bars.c"
    #define oled_render_anim music_bars_oled_render_anim
#elif defined(USE_BONGO_ANIM)
    #include "animations/bongo.c"
    #define oled_render_anim bongo_oled_render_anim
#endif

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    if (!is_keyboard_master()) {
        return OLED_ROTATION_180;  // Rotación 180 grados para todas las animaciones
    }
    return rotation;
}

void oled_render_layer_state(void) {
    oled_write_P(PSTR("Layer: "), false);
    switch (get_highest_layer(layer_state)) {
        case _QWERTY:
            oled_write_ln_P(PSTR("QWERTY"), false);
            break;
        case _NUMS:
            oled_write_ln_P(PSTR("NUMS"), false);
            break;
        case _SYMBOLS:
            oled_write_ln_P(PSTR("SYMBOLS"), false);
            break;
        case _MEDIA:
            oled_write_ln_P(PSTR("MEDIA"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Unknown"), false);
    }
}

void oled_render_lock_status(void) {
    led_t led_state = host_keyboard_led_state();

    oled_write_P(PSTR("Lock: "), false);
    if (led_state.caps_lock) {
        oled_write_P(PSTR("[CAPS]"), true);  // Invertido para resaltar
    } else {
        oled_write_P(PSTR("      "), false);
    }
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_mods(void) {
    uint8_t mods = get_mods() | get_oneshot_mods();

    oled_write_P(PSTR("Mods: "), false);
    oled_write_P((mods & MOD_MASK_SHIFT) ? PSTR("S") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_CTRL)  ? PSTR("C") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_ALT)   ? PSTR("A") : PSTR("-"), false);
    oled_write_P((mods & MOD_MASK_GUI)   ? PSTR("G") : PSTR("-"), false);
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_wpm_status(void) {
    char wpm_str[5];
    sprintf(wpm_str, "%03d", get_current_wpm());
    oled_write_P(PSTR("WPM:  "), false);
    oled_write(wpm_str, false);
    oled_write_ln_P(PSTR(""), false);
}

void oled_render_macro_status(void) {
    if (currently_recording >= 0) {
        oled_write_P(PSTR("REC: M"), true);  // Invertido para destacar
        char macro_num[2];
        sprintf(macro_num, "%d", currently_recording + 1);
        oled_write(macro_num, true);
        oled_write_ln_P(PSTR(""), false);
    } else {
        oled_write_ln_P(PSTR("        "), false);
    }
}

bool oled_task_user(void) {
    if (is_keyboard_master()) {
        // Lado maestro: mostrar información de capas y estado
        oled_render_layer_state();
        oled_render_lock_status();
        oled_render_mods();
        oled_render_macro_status();  // Mostrar si estamos grabando
    } else {
        // Lado secundario: mostrar solo la animación
        oled_render_anim();
    }
    return false;
}
#endif

// Indicadores RGB para Caps Lock y capas
#ifdef RGB_MATRIX_ENABLE
bool rgb_matrix_indicators_user(void) {
    uint8_t current_layer = get_highest_layer(layer_state);

    // Prioridad 1: Mostrar estado de grabación de macro
    if (currently_recording >= 0) {
        // Parpadear todos los LEDs en rojo para indicar grabación activa
        static uint16_t blink_timer = 0;
        static bool blink_state = false;

        if (timer_elapsed(blink_timer) > 500) {  // Parpadeo cada 500ms
            blink_state = !blink_state;
            blink_timer = timer_read();
        }

        if (blink_state) {
            for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
                rgb_matrix_set_color(i, 255, 0, 0);  // ROJO brillante
            }
        }
        return false;
    }

    // Prioridad 2: Detectar si estamos en la capa SYMBOLS
    if (current_layer == _SYMBOLS) {
        // Índices correctos identificados mediante diagnóstico:
        // W: 18, A: 22, S: 19, D: 16
        uint8_t wasd_leds[] = {18, 22, 19, 16};  // W, A, S, D

        // Iterar sobre TODOS los LEDs (ambos lados del teclado)
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            // Verificar si el LED actual es uno de W, A, S, D
            bool is_wasd = false;
            for (uint8_t j = 0; j < sizeof(wasd_leds); j++) {
                if (i == wasd_leds[j]) {
                    is_wasd = true;
                    break;
                }
            }

            if (is_wasd) {
                // W, A, S, D en blanco
                rgb_matrix_set_color(i, 255, 255, 255);
            } else {
                // Resto de LEDs en amarillo (255, 255, 0 en RGB)
                rgb_matrix_set_color(i, 255, 221, 51); // AMARILLO
            }
        }
        return false;
    }

    // Prioridad 3: Detectar si estamos en la capa NUMS
    if (current_layer == _NUMS) {
        // Todos los LEDs en naranja
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            rgb_matrix_set_color(i, 255, 64, 25);  // NARANJA
        }
        return false;
    }

    // Prioridad 4: Detectar si Caps Lock está activo (en capa base)
    if (host_keyboard_led_state().caps_lock) {
        // Poner todos los LEDs en blanco cuando Caps Lock está activo
        // Usar brillo más bajo para evitar problemas
        for (uint8_t i = 0; i < RGB_MATRIX_LED_COUNT; i++) {
            rgb_matrix_set_color(i, 200, 200, 200);  // Blanco suave
        }
    }
    // Si ninguna condición está activa, el RGB Matrix usa el modo configurado (rainbow)
    return false;
}
#endif

#ifdef OTHER_KEYMAP_C
#    include OTHER_KEYMAP_C
#endif // OTHER_KEYMAP_C



